		[" ARRAY SEQUENCES:",
		"<br> <font color=\"green\"># using List, Tuple, String(\"\") </font>"
		+"<br> <font color=\"green\"># To understand how arrays work we need to understand low level computer architecture: </font>"
		+"<br> <font color=\"green\"># * memory stored in bits </font>"
		+"<br> <font color=\"green\"># * 8bits = 1byte </font>"
		+"<br> <font color=\"green\"># * memory address for each byte </font>"
		+"<br> <font color=\"green\"># stored and retrieved in O(1) constant time. </font>"
		+"<br> "
		+"<br> <font color=\"green\"># Python represents UNICODE character with 16 bits (2 bytes) </font>"
		+"<br> <font color=\"green\"># EX: SAMPLE is 6 characters = 12 bytes </font>"
		+"<br> <font color=\"green\"># * ARRAY of characters </font>"
		+"<br> <font color=\"green\"># * Each character takes up a CELL </font>"
		+"<br> <font color=\"green\"># * INDEX describes location </font>"
		,""],
		[" Lists and References",
		"<br> <font color=\"green\"># Create a list called primes, storing prime numbers. </font>"
		+"<br> <font color=\"green\"># If I create a new object temp, and have it reference a portion of my prime list I have created a new but referencing an exiting index location. </font>"
		+"<br> <font color=\"green\"># If I want to change an indexed assignment in new temp list.. </font>"
		+"<br> <font color=\"green\"># temp[2] = 15 </font>"
		+"<br> <font color=\"green\"># The original list is not changed, the new indexed position just points to a different object. </font>"
		+"<br> <font color=\"green\"># Take away = new lists create a shallow copy meaning your only changing/creating your pointers, not duplicating objects in memory. </font>"
		+"<br> <font color=\"green\"># Much of what we are doing is manipulating references and calls, not the objects itself. </font>"
		+"<br> "
		+"<br> import sys"
		+"<br> n=10"
		+"<br> data = []"
		+"<br> for i in range(n):"
		+"<br> &nbsp; &nbsp; a = len(data)"
		+"<br> &nbsp; &nbsp; b = sys.getsizeof(data)"
		+"<br> &nbsp; &nbsp; print(\'Length: {0:3d}; Size in bytes: {1:4d}\'.format(a,b))"
		+"<br> &nbsp; &nbsp; data.append(n)"
		+"<br> <font color=\"green\"># Length:   0; Size in bytes:   64 </font>"
		+"<br> <font color=\"green\"># Length:   1; Size in bytes:   96 </font>"
		+"<br> <font color=\"green\"># Length:   2; Size in bytes:   96 </font>"
		+"<br> <font color=\"green\"># Length:   3; Size in bytes:   96 </font>"
		+"<br> <font color=\"green\"># Length:   4; Size in bytes:   96 </font>"
		+"<br> <font color=\"green\"># Length:   5; Size in bytes:  128 </font>"
		+"<br> <font color=\"green\"># Length:   6; Size in bytes:  128 </font>"
		+"<br> <font color=\"green\"># Length:   7; Size in bytes:  128 </font>"
		+"<br> <font color=\"green\"># Length:   8; Size in bytes:  128 </font>"
		+"<br> <font color=\"green\"># Length:   9; Size in bytes:  192 </font>"
		+"<br> <font color=\"green\"># it create a new sides and it\'s gonna hold it as long as it can and then it\'s going to move that array into a larger array of memory so that it can hold those put but it\'s not point four point it will hold it for a certain number of time and as the length increases then it will jump to the appropriate size of memory of course until you get a memory error. </font>"
		,""],
